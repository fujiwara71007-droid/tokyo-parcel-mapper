<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Tokyo Parcel Mapper - Address Fast</title>
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <style>
    html,body,#map{height:100%;margin:0}
    #ui{position:fixed;top:.5rem;left:.5rem;right:.5rem;background:#fff;padding:.5rem;border-radius:.6rem;
        box-shadow:0 4px 16px rgba(0,0,0,.08);font-family:system-ui;z-index:10}
    #ui .row{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin:.25rem 0}
    .pill{padding:.45rem .6rem;border:1px solid #ddd;border-radius:.6rem;background:#fff}
    .btn{padding:.5rem .8rem;border:1px solid #111;background:#111;color:#fff;border-radius:.6rem}
    #toast{position:fixed;bottom:.8rem;left:50%;transform:translateX(-50%);background:#111;color:#fff;
           padding:.4rem .6rem;border-radius:.6rem;display:none;z-index:20}
    #busy{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:15}
    #busy .box{background:#fff;padding:1rem 1.2rem;border-radius:.8rem;box-shadow:0 8px 24px rgba(0,0,0,.2);font-weight:600}

    /* 現在地ドット＆ビーム（カスタムHTMLマーカー） */
    .me-wrap{position:relative;width:24px;height:24px}
    .me-beam{position:absolute;left:50%;top:50%;width:0;height:0;
      border-left:0 solid transparent;border-right:32px solid rgba(59,130,246,.25);
      border-top:14px solid transparent;border-bottom:14px solid transparent;
      transform-origin:0% 50%; transform:translate(-2px,-50%) rotate(0deg);
      border-radius:14px}
    .me-dot{position:absolute;left:50%;top:50%;width:14px;height:14px;border-radius:999px;
      background:#1d4ed8; box-shadow:0 0 0 3px #fff; transform:translate(-50%,-50%)}
  </style>
</head>
<body>
<div id="map"></div>

<div id="ui">
  <div class="row"><b>Tokyo Parcel Mapper – Address Fast</b></div>
  <div class="row">
    <label class="pill"><input id="follow" type="checkbox" checked> 現在地に追従</label>
    <button id="goto" class="btn">現在地へ</button>
    <button id="heading" class="btn" title="方位センサーを有効化">方位ON</button>
  </div>
  <div class="row">
    <select id="category" class="pill">
      <option>古屋</option><option>古アパート</option><option>更地</option>
      <option>駐車場</option><option>その他</option>
    </select>
    <input id="memo" class="pill" placeholder="メモ（任意）" />
  </div>

  <!-- 選択中の住所（ピンを置くと自動更新） -->
  <div class="row">
    <div id="addrBox" class="pill" style="flex:1;min-width:260px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">
      住所: （まだ選択されていません）
    </div>
  </div>

  <div class="row">
    <input id="photo" class="pill" type="file" accept="image/*" capture="environment" />
    <button id="send" class="btn" disabled>この地点を送信</button>
  </div>

  <div class="row" style="font-size:.9rem;color:#666">
    地図をタップ → ピン作成 → 住所が出たら送信（丁目＋番地まで）。地番は送信しません。
  </div>
</div>

<div id="busy"><div class="box">送信中…</div></div>
<div id="toast"></div>

<script>
  /* ←必要ならあなたの /exec に変更 */
  const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbw4wmqV__4kQO77AJmSLpyuLQH9tSblJJfxCWhIqHdpeEbX23ZZzEj2RV0OpwyK3sv5/exec';
  const GSI_TILE = "https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png";
  const NOMI_EMAIL = 'you@example.com'; // 任意で自分のメールに

  /* ====== 共通ユーティリティ ====== */
  const toast = (m)=>{ const t=document.getElementById('toast'); t.textContent=m;
    t.style.display='block'; clearTimeout(window._to); window._to=setTimeout(()=>t.style.display='none',2200); };
  const showBusy = (on)=>{ document.getElementById('busy').style.display = on ? 'flex' : 'none'; };
  const joinJP = (...p)=> p.filter(Boolean).join('');
  function distMeters(a,b){const R=6378137,toRad=x=>x*Math.PI/180;
    const dLat=toRad(b.lat-a.lat),dLon=toRad(b.lon-a.lon);
    const sa=Math.sin(dLat/2),sb=Math.sin(dLon/2);
    const c=2*Math.asin(Math.sqrt(sa*sa+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*sb*sb));
    return R*c;}
  function smoothHeading(prev, next, alpha=0.25){
    if (prev==null || isNaN(prev)) return next;
    let diff = ((next - prev + 540) % 360) - 180; return (prev + diff*alpha + 360) % 360;
  }
  const toDataURL = (f)=> new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsDataURL(f); });
  function dataUrlBytes(u){ const b64=(u.split(',')[1]||''); return Math.floor((b64.length*3)/4); }
  async function compressImage(file, maxSide=1600, quality=0.7){
    if (!file) return null; const src = await toDataURL(file);
    const img = new Image(); img.src = src; await img.decode();
    const w = img.width, h = img.height, scale = Math.min(1, maxSide/Math.max(w,h));
    const cw = Math.round(w*scale), ch = Math.round(h*scale);
    const canvas = document.createElement('canvas'); canvas.width=cw; canvas.height=ch;
    canvas.getContext('2d').drawImage(img,0,0,cw,ch);
    return canvas.toDataURL('image/jpeg', quality);
  }
  async function fetchT(url, opts={}, ms=7000){
    const ctl = new AbortController(); const t = setTimeout(()=>ctl.abort('timeout'), ms);
    try{ const res = await fetch(url, {...opts, signal: ctl.signal}); return res; }
    finally{ clearTimeout(t); }
  }

  /* ====== 住所：住所だけ（地番なし）を最速で ====== */

  // 町名・丁目＋市区町村：GSI（速い）
  async function gsiTown(lat, lon){
    const url = `https://mreversegeocoder.gsi.go.jp/reverse-geocoder/LonLatToAddress?lat=${lat}&lon=${lon}`;
    const r = await fetchT(url, {}, 5000); if (!r.ok) throw new Error('GSI '+r.status);
    const j = await r.json(); const x = j.results || {};
    return { muni: x.muniNm || '', town: [x.lv01Nm,x.lv02Nm,x.lv03Nm].filter(Boolean).join('') };
  }
  // 都道府県：Nominatim（軽量）
  async function nomiPref(lat, lon){
    const u = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=8&addressdetails=1&accept-language=ja&email=${encodeURIComponent(NOMI_EMAIL)}`;
    const r = await fetchT(u,{headers:{'User-Agent':`TokyoParcelMapper/1.0 (+${NOMI_EMAIL})`}},4500);
    if (!r.ok) return ''; const j = await r.json(); return (j.address||{}).state || '';
  }
  // 番地：Overpass（速い時だけ使う／小半径＋短タイムアウト）
  async function overpassHouseNo(lat, lon){
    const radii=[25,50]; // 小さめ半径
    const eps=['https://overpass-api.de/api/interpreter','https://overpass.kumi.systems/api/interpreter'];
    for (const radius of radii){
      const q = `[out:json][timeout:10];(nwr(around:${radius},${lat},${lon})["addr:housenumber"];nwr(around:${radius},${lat},${lon})["addr:block_number"];nwr(around:${radius},${lat},${lon})["addr:lot_number"];);out center tags 30;`;
      for (const ep of eps){
        try{
          const r = await fetchT(ep,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:'data='+encodeURIComponent(q)},5000);
          if (!r.ok) continue; const j = await r.json(); if (!j.elements?.length) continue;
          // 近いものから番地文字列を
          let best='', bestD=1e9;
          for (const el of j.elements){
            const c = el.center ? {lat:el.center.lat, lon:el.center.lon} : (el.lat?{lat:el.lat,lon:el.lon}:null);
            if (!c) continue;
            const d = distMeters({lat,lon},{lat:c.lat,lon:c.lon});
            const t = el.tags||{}; const hn=t['addr:housenumber']; const bn=t['addr:block_number']; const ln=t['addr:lot_number'];
            const num = hn ? String(hn) : [bn,ln].filter(Boolean).join('-');
            if (!num) continue; if (d<bestD){best=num;bestD=d;}
          }
          if (best) return best;
        }catch(_){}
      }
    }
    return '';
  }
  // 最寄り建物の中心点（道路上クリックズレ対策）
  async function nearestBuildingCenter(lat, lon){
    const q = `[out:json][timeout:10];way(around:100,${lat},${lon})["building"];out center 20;`;
    const eps=['https://overpass-api.de/api/interpreter','https://overpass.kumi.systems/api/interpreter'];
    for (const ep of eps){
      try{
        const r = await fetchT(ep,{method:'POST',headers:{'Content-Type':'application/x-www-form-urlencoded'},body:'data='+encodeURIComponent(q)},5000);
        if (!r.ok) continue; const j = await r.json(); if (!j.elements?.length) continue;
        let best=null, bestD=1e9;
        for (const w of j.elements){
          if (!w.center) continue; const c={lat:w.center.lat,lon:w.center.lon};
          const d=distMeters({lat,lon},c); if (d<bestD){best=c;bestD=d;}
        }
        if (best) return best;
      }catch(_){}
    }
    return null;
  }
  // house_number（最終フォールバック）
  async function nomiHouseNo(lat, lon){
    try{
      const u = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=20&addressdetails=1&accept-language=ja&email=${encodeURIComponent(NOMI_EMAIL)}`;
      const r = await fetchT(u,{headers:{'User-Agent':`TokyoParcelMapper/1.0 (+${NOMI_EMAIL})`}},5000);
      if (!r.ok) return ''; const j = await r.json();
      return (j.address&&j.address.house_number)? String(j.address.house_number):'';
    }catch(_){ return ''; }
  }

  // リクエスト世代（古い住所解決結果を破棄するため）
  let addrGen = 0;

  async function resolveAddress(lat, lon, onProgress){
    const myGen = ++addrGen;

    // 先に町名だけ素早く
    onProgress('取得中…');
    let quick = {muni:'', town:''};
    try { quick = await gsiTown(lat, lon); } catch(_){}
    if (myGen !== addrGen) return null; // キャンセル
    if (quick.muni || quick.town) onProgress(joinJP('', quick.muni, quick.town));

    // 並列で：都道府県・番地
    const prefP = nomiPref(lat, lon);
    // 番地は Overpass と Nominatim を並列→ダメなら建物中心でNominatim
    const houseP = (async()=>{
      const [a,b] = await Promise.allSettled([overpassHouseNo(lat,lon), nomiHouseNo(lat,lon)]);
      let hn = (a.status==='fulfilled' && a.value)?a.value : (b.status==='fulfilled'&&b.value)?b.value : '';
      if (!hn){
        const c = await nearestBuildingCenter(lat, lon);
        if (c) hn = await nomiHouseNo(c.lat, c.lon);
      }
      return hn || '';
    })();

    const [pref, house] = await Promise.allSettled([prefP, houseP]);
    if (myGen !== addrGen) return null; // キャンセル

    const state = pref.status==='fulfilled'?pref.value:'';
    const hn    = house.status==='fulfilled'?house.value:'';
    const line  = joinJP(state, quick.muni, quick.town, hn||'');
    return line;
  }

  /* ====== MapLibre 初期化 ====== */
  const map = new maplibregl.Map({
    container:'map',
    style:{ version:8, sources:{ gsi:{ type:'raster', tiles:[GSI_TILE], tileSize:256, attribution:'地理院タイル' } },
            layers:[ { id:'gsi', type:'raster', source:'gsi' } ] },
    center:[139.7671,35.6812], zoom:14
  });

  /* ====== 現在地（ゆらぎ抑制＋方位） ====== */
  let follow = true, watchId=null, headingDeg=0;
  const meEl = document.createElement('div'); meEl.className='me-wrap';
  meEl.innerHTML = '<div class="me-beam" id="beam"></div><div class="me-dot"></div>';
  const me = new maplibregl.Marker({ element: meEl, rotationAlignment:'map' });
  const beamEl = ()=> meEl.querySelector('#beam');

  let smoothed=null, lastRaw=null, lastUpdateAt=0;
  function applyPosition(coords){
    const now = performance.now();
    const acc = coords.accuracy || 9999;
    const fresh = {lat:coords.latitude, lon:coords.longitude};
    if (acc > 50) return;
    if (now - lastUpdateAt < 500) return;
    if (lastRaw){
      const move = distMeters(lastRaw, fresh);
      const threshold = Math.max(3, acc*0.5);
      if (move < threshold) return;
    }
    const alpha=0.25;
    smoothed = smoothed ? { lat: smoothed.lat+(fresh.lat-smoothed.lat)*alpha,
                            lon: smoothed.lon+(fresh.lon-smoothed.lon)*alpha } : fresh;
    me.setLngLat([smoothed.lon, smoothed.lat]).addTo(map);
    if (follow) map.easeTo({center:[smoothed.lon, smoothed.lat], duration:500});
    if (typeof coords.heading==='number' && !isNaN(coords.heading)){
      headingDeg = smoothHeading(headingDeg, coords.heading, 0.25);
      beamEl().style.transform = `translate(-2px,-50%) rotate(${headingDeg}deg)`;
    }
    lastRaw=fresh; lastUpdateAt=now;
  }

  map.on('load', ()=>{
    if (!navigator.geolocation){ toast('位置情報が使えません'); return; }
    watchId = navigator.geolocation.watchPosition(
      p => applyPosition(p.coords),
      _ => toast('位置情報取得に失敗'),
      { enableHighAccuracy:true, maximumAge:5000, timeout:15000 }
    );
  });
  document.getElementById('follow').onchange = (e)=> follow = e.target.checked;
  document.getElementById('goto').onclick = ()=> { follow=true; document.getElementById('follow').checked=true; };

  async function enableHeading(){
    try{
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === 'function'){
        const st = await DeviceOrientationEvent.requestPermission();
        if (st !== 'granted'){ toast('方位センサーが許可されませんでした'); return; }
      }
      window.addEventListener('deviceorientation', (ev)=>{
        const raw = (ev.webkitCompassHeading != null) ? ev.webkitCompassHeading : (360 - (ev.alpha||0));
        if (!isNaN(raw)){
          headingDeg = smoothHeading(headingDeg, raw, 0.2);
          beamEl().style.transform = `translate(-2px,-50%) rotate(${headingDeg}deg)`;
        }
      }, true);
      toast('方位センサーON');
    }catch(_){ toast('方位センサー利用不可'); }
  }
  document.getElementById('heading').onclick = enableHeading;

  /* ====== タップ → ピン設置＆住所解決（キャンセル対応） ====== */
  const pin = new maplibregl.Marker({ color:'#111' });
  let last = null;

  async function setSelection(lng, lat){
    pin.setLngLat([lng,lat]).addTo(map);
    last = { lat, lon: lng, address: '' };
    document.getElementById('send').disabled = true;
    const box = document.getElementById('addrBox');

    // 住所解決（古いリクエストは破棄）
    const line = await resolveAddress(lat, lng, (txt)=>{ box.textContent = '住所: ' + txt; });
    if (line==null) return; // キャンセル
    last.address = line || '';
    box.textContent = '住所: ' + (last.address || '取得できませんでした');
    document.getElementById('send').disabled = false;
  }
  map.on('click', (e)=>{ const {lng,lat}=e.lngLat; setSelection(lng,lat); });

  /* ====== 送信（住所のみ送る／送信中ロック／再送キュー） ====== */
  let sending = false;
  document.getElementById('send').onclick = async ()=>{
    if (!last){ toast('地図をタップして地点を選んでください'); return; }
    if (sending) return;
    sending = true; document.getElementById('send').disabled = true; showBusy(true);

    try{
      const category = document.getElementById('category').value;
      const memo = document.getElementById('memo').value.trim();
      const file = document.getElementById('photo').files[0];

      let photo = null, photoName = null;
      if (file){
        try{
          photo = await compressImage(file, 1600, 0.7);
          photoName = (file.name || 'photo.jpg').replace(/\.[^.]+$/, '.jpg');
          const kb = Math.round(dataUrlBytes(photo)/1024);
          toast(`写真を添付（約 ${kb} KB）`);
        }catch(_){}
      }

      const payload = {
        timestamp: new Date().toISOString(), // JST化はGAS側
        lat: last.lat, lon: last.lon,
        category, memo,
        address: last.address || '', // ★地番は送らない
        photo, photoName
      };

      const res = await fetch(GAS_ENDPOINT, {
        method:'POST', mode:'cors',
        headers:{ 'Content-Type':'text/plain' },
        body: JSON.stringify(payload)
      });
      if (!res.ok) throw new Error('HTTP '+res.status);
      toast('送信しました（シートに保存）');
      document.getElementById('memo').value='';
      document.getElementById('photo').value='';
    }catch(e){
      toast('送信に失敗。電波復帰後に再送します');
      const q = JSON.parse(localStorage.getItem('queue')||'[]');
      q.push({timestamp:new Date().toISOString(), lat:last.lat, lon:last.lon,
              category:document.getElementById('category').value,
              memo:document.getElementById('memo').value.trim(),
              address:last.address||'', photo:null, photoName:null});
      localStorage.setItem('queue', JSON.stringify(q));
    }finally{
      sending = false; document.getElementById('send').disabled = false; showBusy(false);
    }
  };

  async function flush(){
    const q = JSON.parse(localStorage.getItem('queue')||'[]'); if (!q.length) return;
    for (const item of q){
      try{
        const r = await fetch(GAS_ENDPOINT,{method:'POST',headers:{'Content-Type':'text/plain'},body:JSON.stringify(item)});
        if (!r.ok) throw 0;
      }catch{ return; }
    }
    localStorage.removeItem('queue'); toast('オフライン分を再送しました');
  }
  window.addEventListener('online', flush); flush();
</script>
</body>
</html>
